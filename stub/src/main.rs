// Hide console window on Windows in release mode
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use serde::Deserialize;
use std::env;
use std::fs::{self, File};
use std::io::{self, Read};
use std::path::PathBuf;
use std::process::Command;

/// Unique binary marker (not a string) to avoid false positives in the binary
const PORTABLE_MARKER: &[u8] = &[0xDE, 0xAD, 0xBE, 0xEF, 0x45, 0x4D, 0x55, 0x46, 0x4F, 0x52, 0x47, 0x45, 0x56, 0x32];

// Include the config generated by build.rs
include!(concat!(env!("OUT_DIR"), "/config_gen.rs"));

#[derive(Deserialize)]
#[allow(dead_code)]
struct LaunchConfig {
    emulator_path: PathBuf,
    rom_path: PathBuf,
    #[allow(dead_code)]
    bios_path: Option<PathBuf>,
    args: Vec<String>,
    #[serde(default)]
    args_after_rom: Vec<String>,
    working_dir: Option<PathBuf>,
    env_vars: Vec<(String, String)>,
}

#[derive(Deserialize)]
struct PortableConfig {
    game_name: String,
    emulator_filename: String,
    rom_filename: String,
    config_dir: String,
    #[allow(dead_code)]
    fullscreen: bool,
    #[serde(default)]
    env_vars: Vec<(String, String)>,
    #[serde(default)]
    args_before_rom: Vec<String>,
    #[serde(default)]
    args_after_rom: Vec<String>,
}

fn main() {
    // Check if we're in portable mode by looking for the marker in ourselves
    let exe_path = env::current_exe().expect("Failed to get current exe path");
    
    if let Some(portable_config) = check_portable_mode(&exe_path) {
        run_portable_mode(exe_path, portable_config);
    } else {
        run_launcher_mode();
    }
}

/// Check if the executable contains embedded portable data
fn check_portable_mode(exe_path: &PathBuf) -> Option<PortableConfig> {
    let mut file = File::open(exe_path).ok()?;
    
    // We only need to read the beginning of the file to find the marker
    // because the marker is appended directly after the stub binary.
    // 10MB is more than enough for any stub binary.
    let mut buffer = vec![0u8; 10 * 1024 * 1024]; 
    let bytes_read = file.read(&mut buffer).ok()?;
    buffer.truncate(bytes_read);
    
    // Search for marker starting from the END of the buffer to find the REAL one
    if let Some(pos) = buffer.windows(PORTABLE_MARKER.len()).rposition(|window| window == PORTABLE_MARKER) {
        // Marker found! Read the config JSON that follows
        let config_start = pos + PORTABLE_MARKER.len();
        
        // Read 4 bytes for config length
        if buffer.len() < config_start + 4 {
            return None;
        }
        let config_len = u32::from_le_bytes([
            buffer[config_start],
            buffer[config_start + 1],
            buffer[config_start + 2],
            buffer[config_start + 3],
        ]) as usize;
        
        let config_data_start = config_start + 4;
        if buffer.len() < config_data_start + config_len {
            return None;
        }
        
        let config_json = &buffer[config_data_start..config_data_start + config_len];
        serde_json::from_slice::<PortableConfig>(config_json).ok()
    } else {
        None
    }
}

/// Find subsequence in buffer

/// Run in portable mode - extract and launch
fn run_portable_mode(exe_path: PathBuf, config: PortableConfig) {
    // Determine cache directory
    let cache_base = dirs::cache_dir()
        .unwrap_or_else(|| PathBuf::from("/tmp"))
        .join("emuforge");
    let target_dir = cache_base.join(&config.game_name);
    
    // Check if already extracted
    let marker_file = target_dir.join(".emuforge_extracted");
    let needs_extraction = !marker_file.exists();
    
    if needs_extraction {
        eprintln!("üéÆ Pr√©paration du jeu: {}...", config.game_name);
        eprintln!("üìÅ Dossier de donn√©es: {:?}", target_dir);
        
        // Create cache directory
        fs::create_dir_all(&target_dir).expect("Failed to create cache directory");
        
        // Extract the embedded zip archive
        if let Err(e) = extract_embedded_archive(&exe_path, &target_dir) {
            eprintln!("‚ùå Erreur d'extraction: {}", e);
            std::process::exit(1);
        }
        
        // Create marker file
        let _ = File::create(&marker_file);
        eprintln!("‚úÖ Extraction termin√©e !");
    } else {
        // Even if already extracted, we RE-EXTRACT ONLY THE CONFIG to ensure resolution settings
        // are updated if the user changed them.
        let _ = extract_embedded_archive(&exe_path, &target_dir);
    }
    
    // Build paths to extracted files
    let mut emulator_path = target_dir.join(&config.emulator_filename);
    let rom_path = target_dir.join(&config.rom_filename);
    let config_path = target_dir.join(&config.config_dir);
    
    // If emulator is a directory (e.g., extracted AppImage squashfs-root), use AppRun inside it
    if emulator_path.is_dir() {
        let app_run = emulator_path.join("AppRun");
        if app_run.exists() {
            eprintln!("üìÅ Emulator is a directory, using AppRun launcher");
            emulator_path = app_run;
        }
    }
    
    // Make emulator executable (Linux)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        if let Ok(metadata) = fs::metadata(&emulator_path) {
            let mut perms = metadata.permissions();
            perms.set_mode(0o755);
            let _ = fs::set_permissions(&emulator_path, perms);
        }
    }
    
    // Check for --clean argument
    let args: Vec<String> = env::args().collect();
    let clean_mode = args.contains(&"--clean".to_string());
    
    // Launch the emulator
    let mut cmd = Command::new(&emulator_path);
    
    // Set working directory to the extraction folder to avoid polluting the user's current directory
    // and ensure relative paths work as expected.
    cmd.current_dir(&target_dir);
    
    // === GENERIC LAUNCH LOGIC (from plugin config) ===
    
    // Apply environment variables from config (with path substitution)
    for (key, value) in &config.env_vars {
        // Substitute {config_dir} placeholder with actual path
        let resolved_value = value.replace("{config_dir}", &config_path.to_string_lossy());
        
        // Handle relative paths ONLY if they start with ./
        // This prevents strings like "xcb" or "wayland" from being treated as paths
        let final_value = if resolved_value.starts_with("./") {
            target_dir.join(&resolved_value).to_string_lossy().to_string()
        } else {
            resolved_value
        };
        
        eprintln!("üîß ENV: {} = {}", key, final_value);
        cmd.env(key, &final_value);
    }
    
    // Add args before ROM
    for arg in &config.args_before_rom {
        cmd.arg(arg);
    }
    
    // Add ROM path
    cmd.arg(&rom_path);
    
    // Add args after ROM
    for arg in &config.args_after_rom {
        cmd.arg(arg);
    }
    
    let mut child = cmd.spawn().expect("Failed to launch emulator");
    let _ = child.wait();
    
    if clean_mode {
        eprintln!("üßπ Nettoyage du cache demand√©...");
        if let Err(e) = fs::remove_dir_all(&target_dir) {
            eprintln!("‚ùå Erreur lors du nettoyage du cache: {}", e);
        } else {
            eprintln!("‚úÖ Cache nettoy√© avec succ√®s: {:?}", target_dir);
        }
    }
}

/// Extract the embedded ZIP archive from the executable
fn extract_embedded_archive(exe_path: &PathBuf, target_dir: &PathBuf) -> io::Result<()> {
    use std::io::{Seek, SeekFrom};
    let mut file = File::open(exe_path)?;
    
    // Search for the marker in the first 10MB
    let mut header = vec![0u8; 10 * 1024 * 1024];
    let n = file.read(&mut header)?;
    header.truncate(n);
    
    // Search for marker starting from the END of the buffer
    if let Some(pos) = header.windows(PORTABLE_MARKER.len()).rposition(|window| window == PORTABLE_MARKER) {
        let config_start = pos + PORTABLE_MARKER.len();
        
        // Read config length (4 bytes)
        let config_len = u32::from_le_bytes([
            header[config_start],
            header[config_start + 1],
            header[config_start + 2],
            header[config_start + 3],
        ]) as usize;
        
        let zip_start = (config_start + 4 + config_len) as u64;
        
        // Seek to the start of ZIP data
        file.seek(SeekFrom::Start(zip_start))?;
        
        // Write ZIP to temporary file by streaming
        let zip_temp_path = target_dir.join("temp_data.zip");
        let mut temp_file = File::create(&zip_temp_path)?;
        io::copy(&mut file, &mut temp_file)?;
        
        // Extract ZIP
        let zip_read_file = File::open(&zip_temp_path)?;
        let mut archive = zip::ZipArchive::new(zip_read_file)?;
        
        for i in 0..archive.len() {
            let mut out_file = archive.by_index(i)?;
            let outpath = match out_file.enclosed_name() {
                Some(path) => target_dir.join(path),
                None => continue,
            };
            
            if out_file.name().ends_with('/') {
                fs::create_dir_all(&outpath)?;
            } else {
                if let Some(p) = outpath.parent() {
                    if !p.exists() {
                        fs::create_dir_all(&p)?;
                    }
                }
                
                eprintln!("üìÑ Extraction: {} ({} bytes)", out_file.name(), out_file.size());
                
                let mut outfile = File::create(&outpath)?;
                io::copy(&mut out_file, &mut outfile)?;
                
                // Set executable permissions if needed (Linux)
                #[cfg(unix)]
                {
                    use std::os::unix::fs::PermissionsExt;
                    if let Some(mode) = out_file.unix_mode() {
                        fs::set_permissions(&outpath, fs::Permissions::from_mode(mode)).ok();
                    }
                }
            }
        }
        
        // Remove temporary ZIP
        let _ = fs::remove_file(&zip_temp_path);
        Ok(())
    } else {
        Err(io::Error::new(io::ErrorKind::NotFound, "Marker not found"))
    }
}

/// Run in launcher mode - use embedded config
fn run_launcher_mode() {
    let config: LaunchConfig = serde_json::from_str(CONFIG_JSON)
        .expect("Failed to parse embedded config");

    let mut cmd = Command::new(&config.emulator_path);
    
    if let Some(working_dir) = config.working_dir {
        cmd.current_dir(working_dir);
    }

    for (key, value) in config.env_vars {
        cmd.env(key, value);
    }

    // Determine if we need DuckStation specific HOME isolation
    let is_duckstation = config.emulator_path.to_string_lossy().to_lowercase().contains("duckstation");
    if is_duckstation {
        // Find if we have a .duckstation_home next to the executable
        if let Ok(exe_path) = env::current_exe() {
            if let Some(exe_dir) = exe_path.parent() {
                let fake_home = exe_dir.join(".duckstation_home");
                if fake_home.exists() {
                    cmd.env("HOME", fake_home);
                    cmd.env("QT_QPA_PLATFORM", "xcb");
                }
            }
        }
    }

    cmd.args(&config.args);
    
    // In launcher mode, if rom_path is not empty, we add it.
    // If it's a wrapper script, rom_path might have been cleared in the UI logic.
    if !config.rom_path.as_os_str().is_empty() {
        cmd.arg(&config.rom_path);
    }

    // Add arguments that come AFTER the ROM path (e.g., Cemu's -f for fullscreen)
    cmd.args(&config.args_after_rom);

    let mut child = cmd.spawn().expect("Failed to launch emulator");
    let _ = child.wait();
}
