// Hide console window on Windows in release mode
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

mod ryujinx_input;

use serde::Deserialize;
use std::env;
use std::fs::{self, File};
use std::io::{self, Read};
use std::path::PathBuf;
use std::process::Command;

/// Unique binary marker (not a string) to avoid false positives in the binary
const PORTABLE_MARKER: &[u8] = &[0xDE, 0xAD, 0xBE, 0xEF, 0x45, 0x4D, 0x55, 0x46, 0x4F, 0x52, 0x47, 0x45, 0x56, 0x32];

// Include the config generated by build.rs
include!(concat!(env!("OUT_DIR"), "/config_gen.rs"));

#[derive(Deserialize)]
#[allow(dead_code)]
struct LaunchConfig {
    emulator_path: PathBuf,
    rom_path: PathBuf,
    #[allow(dead_code)]
    bios_path: Option<PathBuf>,
    args: Vec<String>,
    #[serde(default)]
    args_after_rom: Vec<String>,
    working_dir: Option<PathBuf>,
    env_vars: Vec<(String, String)>,
}

#[derive(Deserialize)]
struct PortableConfig {
    game_name: String,
    emulator_filename: String,
    rom_filename: String,
    config_dir: String,
    #[allow(dead_code)]
    fullscreen: bool,
    #[serde(default)]
    env_vars: Vec<(String, String)>,
    #[serde(default)]
    args_before_rom: Vec<String>,
    #[serde(default)]
    args_after_rom: Vec<String>,
    #[serde(default)]
    driver_id: String,  // Identifiant du plugin (ryujinx, pcsx2, etc.)
}

fn main() {
    // Check if we're in portable mode by looking for the marker in ourselves
    let exe_path = env::current_exe().expect("Failed to get current exe path");
    
    if let Some(portable_config) = check_portable_mode(&exe_path) {
        run_portable_mode(exe_path, portable_config);
    } else {
        run_launcher_mode();
    }
}

/// Check if the executable contains embedded portable data
fn check_portable_mode(exe_path: &PathBuf) -> Option<PortableConfig> {
    let mut file = File::open(exe_path).ok()?;
    
    // We only need to read the beginning of the file to find the marker
    // because the marker is appended directly after the stub binary.
    // 10MB is more than enough for any stub binary.
    let mut buffer = vec![0u8; 10 * 1024 * 1024]; 
    let bytes_read = file.read(&mut buffer).ok()?;
    buffer.truncate(bytes_read);
    
    // Search for marker starting from the END of the buffer to find the REAL one
    if let Some(pos) = buffer.windows(PORTABLE_MARKER.len()).rposition(|window| window == PORTABLE_MARKER) {
        // Marker found! Read the config JSON that follows
        let config_start = pos + PORTABLE_MARKER.len();
        
        // Read 4 bytes for config length
        if buffer.len() < config_start + 4 {
            return None;
        }
        let config_len = u32::from_le_bytes([
            buffer[config_start],
            buffer[config_start + 1],
            buffer[config_start + 2],
            buffer[config_start + 3],
        ]) as usize;
        
        let config_data_start = config_start + 4;
        if buffer.len() < config_data_start + config_len {
            return None;
        }
        
        let config_json = &buffer[config_data_start..config_data_start + config_len];
        serde_json::from_slice::<PortableConfig>(config_json).ok()
    } else {
        None
    }
}

/// Find subsequence in buffer

/// Run in portable mode - extract and launch
fn run_portable_mode(exe_path: PathBuf, config: PortableConfig) {
    // Determine cache directory
    let cache_base = dirs::cache_dir()
        .unwrap_or_else(|| PathBuf::from("/tmp"))
        .join("emuforge");
    let target_dir = cache_base.join(&config.game_name);
    
    // Check if already extracted
    let marker_file = target_dir.join(".emuforge_extracted");
    let needs_extraction = !marker_file.exists();
    
    if needs_extraction {
        eprintln!("üéÆ Pr√©paration du jeu: {}...", config.game_name);
        eprintln!("üìÅ Dossier de donn√©es: {:?}", target_dir);
        
        // Create cache directory
        fs::create_dir_all(&target_dir).expect("Failed to create cache directory");
        
        // Extract the embedded zip archive
        if let Err(e) = extract_embedded_archive(&exe_path, &target_dir) {
            eprintln!("‚ùå Erreur d'extraction: {}", e);
            std::process::exit(1);
        }
        
        // Create marker file
        let _ = File::create(&marker_file);
        eprintln!("‚úÖ Extraction termin√©e !");
    } else {
        // Even if already extracted, we RE-EXTRACT ONLY THE CONFIG to ensure resolution settings
        // are updated if the user changed them.
        let _ = extract_embedded_archive(&exe_path, &target_dir);
    }
    
    // Build paths to extracted files
    let mut emulator_path = target_dir.join(&config.emulator_filename);
    let rom_path = target_dir.join(&config.rom_filename);
    let config_path = target_dir.join(&config.config_dir);
    
    // If emulator is a directory (e.g., extracted AppImage squashfs-root), use AppRun inside it
    if emulator_path.is_dir() {
        let app_run = emulator_path.join("AppRun");
        if app_run.exists() {
            eprintln!("üìÅ Emulator is a directory, using AppRun launcher");
            emulator_path = app_run;
        }
    }
    
    // Make emulator executable (Linux)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        
        // Helper function for recursive chmod
        fn set_perms_recursive(path: &std::path::Path) {
            if let Ok(metadata) = fs::metadata(path) {
                let mut perms = metadata.permissions();
                perms.set_mode(0o755);
                let _ = fs::set_permissions(path, perms);
                
                if path.is_dir() {
                    if let Ok(entries) = fs::read_dir(path) {
                        for entry in entries.flatten() {
                            set_perms_recursive(&entry.path());
                        }
                    }
                }
            }
        }
        
        // Apply permissions to the entire extraction directory to ensure all bundled binaries/scripts work
        set_perms_recursive(&target_dir);
    }
    
    // Check for --clean argument
    let args: Vec<String> = env::args().collect();
    let clean_mode = args.contains(&"--clean".to_string());
    
    // CHECK PERMISSIONS BEFORE LAUNCH
    eprintln!("üîç DEBUG: Checking executable before launch: {:?}", emulator_path);
    if let Ok(metadata) = fs::symlink_metadata(&emulator_path) {
        use std::os::unix::fs::PermissionsExt;
        let mode = metadata.permissions().mode();
        eprintln!("   üìù Type: {:?} | Mode: {:o}", metadata.file_type(), mode);
        if metadata.file_type().is_symlink() {
            if let Ok(target) = fs::read_link(&emulator_path) {
                eprintln!("   üîó Symlink points to: {:?}", target);
                // Check target perms
                let resolved = if target.is_absolute() { target } else { emulator_path.parent().unwrap().join(target) };
                if let Ok(t_meta) = fs::metadata(&resolved) {
                    eprintln!("   üéØ Target Mode: {:o}", t_meta.permissions().mode());
                } else {
                    eprintln!("   ‚ùå Target not found!");
                }
            }
        }
    } else {
        eprintln!("   ‚ùå Invalid path (metadata failed)");
    }

    // === D√âTECTION DYNAMIQUE DES MANETTES POUR RYUJINX ===
    // Utilise driver_id de la config portable (plus fiable que deviner √† partir du nom)
    if config.driver_id == "ryujinx" {
        eprintln!("üéÆ D√©tection dynamique des manettes pour Ryujinx (mode portable)...");
        // Ryujinx lit toujours depuis ~/.config/Ryujinx/ m√™me en mode portable
        if let Err(e) = ryujinx_input::update_ryujinx_input_config() {
            eprintln!("‚ö†Ô∏è Erreur config manettes: {}", e);
        }
    }
    
    // === D√âTECTION DYNAMIQUE DES MANETTES POUR AZAHAR ===
    // Basculer automatiquement entre profil Manette (0) et Clavier (1)
    if config.driver_id == "azahar" {
        // Simple log for detection start
        // eprintln!("üéÆ [Azahar] D√©but d√©tection manettes...");
        
        // Fetch dynamic GUID first (Best method: uses SDL2)
        let guid = ryujinx_input::get_first_controller_guid();
        
        // Fallback detection via filesystem
        let fs_gamepad = detect_gamepad();
        
        // Determine if we have a gamepad:
        // 1. GUID found via SDL2 (most reliable)
        // 2. FS detection found JS or Event device (fallback if SDL fails)
        let has_gamepad = guid.is_some() || fs_gamepad;
        
        let profile_index = if has_gamepad { 0 } else { 1 };
        
        // Resolve config path dynamically from env vars (like in launcher mode)
        let mut config_home = None;
        for (key, val) in &config.env_vars {
             if key == "XDG_CONFIG_HOME" {
                 // We need to resolve the placeholder manually here as we haven't launched the process yet
                 let resolved_val = val.replace("{config_dir}", &config_path.to_string_lossy());
                 // Handle relative paths
                 let final_path = if resolved_val.starts_with("./") {
                     target_dir.join(&resolved_val).to_string_lossy().to_string()
                 } else {
                     resolved_val
                 };
                 config_home = Some(PathBuf::from(final_path));
                 break;
             }
        }

        // Use resolved path or fallback to previous hardcoded guess (though incorrect)
        let config_file = if let Some(home) = config_home {
            home.join("azahar-emu/qt-config.ini")
        } else {
            target_dir.join("config/azahar-emu/qt-config.ini")
        };
        
        eprintln!("   üìÇ [Azahar-Portable] Config cible: {:?}", config_file);
        
        if config_file.exists() {
             if let Some(ref g) = guid {
                 eprintln!("   üéÆ GUID d√©tect√© et inject√©: {}", g);
             } else if has_gamepad {
                 eprintln!("   üéÆ Manette d√©tect√©e (FS) mais √©chec lecture GUID SDL. Utilisation GUID par d√©faut.");
             }

             // Only log action
            if let Err(e) = update_azahar_profile(&config_file, profile_index, guid.as_deref()) {
                eprintln!("‚ö†Ô∏è [Azahar] Erreur changement profil: {}", e);
            } else {
                eprintln!("‚úÖ [Azahar] Profil activ√©: {} ({})", profile_index, if has_gamepad { "Manette" } else { "Clavier" });
            }
        }
    }

    // Launch the emulator
    let mut cmd = Command::new(&emulator_path);
    
    // Set working directory to the extraction folder to avoid polluting the user's current directory
    // and ensure relative paths work as expected.
    cmd.current_dir(&target_dir);
    eprintln!("üìÇ CWD set to: {:?}", target_dir);
    
    // === GENERIC LAUNCH LOGIC (from plugin config) ===
    
    // Apply environment variables from config (with path substitution)
    for (key, value) in &config.env_vars {
        // Substitute {config_dir} placeholder with actual path
        let resolved_value = value.replace("{config_dir}", &config_path.to_string_lossy());
        
        // Handle relative paths ONLY if they start with ./
        // This prevents strings like "xcb" or "wayland" from being treated as paths
        let final_value = if resolved_value.starts_with("./") {
            target_dir.join(&resolved_value).to_string_lossy().to_string()
        } else {
            resolved_value
        };
        
        eprintln!("üîß ENV: {} = {}", key, final_value);
        cmd.env(key, &final_value);
    }
    
    // Add args before ROM
    for arg in &config.args_before_rom {
        cmd.arg(arg);
    }
    
    // Add ROM path
    cmd.arg(&rom_path);
    
    // Add args after ROM
    for arg in &config.args_after_rom {
        cmd.arg(arg);
    }
    
    let mut child = cmd.spawn().expect("Failed to launch emulator");
    let _ = child.wait();
    
    if clean_mode {
        eprintln!("üßπ Nettoyage du cache demand√©...");
        if let Err(e) = fs::remove_dir_all(&target_dir) {
            eprintln!("‚ùå Erreur lors du nettoyage du cache: {}", e);
        } else {
            eprintln!("‚úÖ Cache nettoy√© avec succ√®s: {:?}", target_dir);
        }
    }
}

/// Extract the embedded ZIP archive from the executable
fn extract_embedded_archive(exe_path: &PathBuf, target_dir: &PathBuf) -> io::Result<()> {
    use std::io::{Seek, SeekFrom};
    let mut file = File::open(exe_path)?;
    
    // Search for the marker in the first 10MB
    let mut header = vec![0u8; 10 * 1024 * 1024];
    let n = file.read(&mut header)?;
    header.truncate(n);
    
    // Search for marker starting from the END of the buffer
    if let Some(pos) = header.windows(PORTABLE_MARKER.len()).rposition(|window| window == PORTABLE_MARKER) {
        let config_start = pos + PORTABLE_MARKER.len();
        
        // Read config length (4 bytes)
        let config_len = u32::from_le_bytes([
            header[config_start],
            header[config_start + 1],
            header[config_start + 2],
            header[config_start + 3],
        ]) as usize;
        
        let zip_start = (config_start + 4 + config_len) as u64;
        
        // Seek to the start of ZIP data
        file.seek(SeekFrom::Start(zip_start))?;
        
        // Write ZIP to temporary file by streaming
        let zip_temp_path = target_dir.join("temp_data.zip");
        let mut temp_file = File::create(&zip_temp_path)?;
        io::copy(&mut file, &mut temp_file)?;
        
        // Extract ZIP
        let zip_read_file = File::open(&zip_temp_path)?;
        let mut archive = zip::ZipArchive::new(zip_read_file)?;
        
        for i in 0..archive.len() {
            let mut out_file = archive.by_index(i)?;
            let outpath = match out_file.enclosed_name() {
                Some(path) => target_dir.join(path),
                None => continue,
            };
            
            if out_file.name().ends_with('/') {
                fs::create_dir_all(&outpath)?;
            } else {
                if let Some(p) = outpath.parent() {
                    if !p.exists() {
                        fs::create_dir_all(&p)?;
                    }
                }
                
                eprintln!("üìÑ Extraction: {} ({} bytes)", out_file.name(), out_file.size());
                
                let mut outfile = File::create(&outpath)?;
                io::copy(&mut out_file, &mut outfile)?;
                
                // Set executable permissions if needed (Linux)
                #[cfg(unix)]
                {
                    use std::os::unix::fs::PermissionsExt;
                    if let Some(mode) = out_file.unix_mode() {
                        fs::set_permissions(&outpath, fs::Permissions::from_mode(mode)).ok();
                    }
                }
            }
        }
        
        // Remove temporary ZIP
        let _ = fs::remove_file(&zip_temp_path);
        Ok(())
    } else {
        Err(io::Error::new(io::ErrorKind::NotFound, "Marker not found"))
    }
}

/// Run in launcher mode - use embedded config
fn run_launcher_mode() {
    let mut config: LaunchConfig = serde_json::from_str(CONFIG_JSON)
        .expect("Failed to parse embedded config");

    // Fix for patched AppImages (Ryujinx) which are directories
    if config.emulator_path.is_dir() {
        let app_run = config.emulator_path.join("AppRun");
        if app_run.exists() {
            eprintln!("üìÅ Emulator path is a directory. Automatically using internal AppRun: {:?}", app_run);
            config.emulator_path = app_run;
        } else {
             // Try to find a binary with the same name as the folder?
             // Or just warn
             eprintln!("‚ö†Ô∏è Emulator path is a directory but no AppRun found. Launch might fail.");
        }
    }

    // === D√âTECTION DYNAMIQUE DES MANETTES POUR RYUJINX ===
    if is_ryujinx_emulator(&config.emulator_path) {
        eprintln!("üéÆ D√©tection dynamique des manettes pour Ryujinx...");
        if let Err(e) = ryujinx_input::update_ryujinx_input_config() {
            eprintln!("‚ö†Ô∏è Erreur config manettes: {}", e);
        }
    }

    // === D√âTECTION DYNAMIQUE DES MANETTES POUR AZAHAR (LAUNCHER MODE) ===
    // Check if emulator path contains "azahar" or "lime3ds"
    let emu_lower = config.emulator_path.to_string_lossy().to_lowercase();
    if emu_lower.contains("azahar") || emu_lower.contains("lime3ds") {
         eprintln!("üéÆ [Azahar-Launcher] D√©but d√©tection manettes...");
         
         // 1. Detect Gamepad
         if let Ok(entries) = std::fs::read_dir("/dev/input") {
             for entry in entries.flatten() {
                 if let Some(name) = entry.file_name().to_str() {
                     if name.starts_with("js") {
                         eprintln!("      üïπÔ∏è Trouv√©: {:?}", name);
                     }
                 }
             }
         }
         
         let has_gamepad = detect_gamepad();
         let profile_index = if has_gamepad { 0 } else { 1 };
         eprintln!("   üìä [Azahar-Launcher] Manette: {} -> Profil: {}", has_gamepad, profile_index);
         
         // 2. Find config path via XDG_CONFIG_HOME in env_vars
         let mut config_home = None;
         for (key, val) in &config.env_vars {
             if key == "XDG_CONFIG_HOME" {
                 config_home = Some(PathBuf::from(val));
                 break;
             }
         }
         
         if let Some(path) = config_home {
             let config_file = path.join("azahar-emu/qt-config.ini");
             eprintln!("   üìÇ [Azahar-Launcher] Config cible: {:?}", config_file);
             
             if config_file.exists() {
                 eprintln!("   ‚úÖ Fichier trouv√©. Mise √† jour...");
                 
                 // Fetch dynamic GUID
                 let guid = ryujinx_input::get_first_controller_guid();
                 if let Some(ref g) = guid {
                     eprintln!("   üéÆ GUID d√©tect√© et inject√©: {}", g);
                 }
                 
                 if let Err(e) = update_azahar_profile(&config_file, profile_index, guid.as_deref()) {
                     eprintln!("   ‚ö†Ô∏è Erreur mise √† jour: {}", e);
                 } else {
                     eprintln!("   ‚úÖ Profil mis √† jour vers: {}", profile_index);
                 }
             } else {
                 eprintln!("   ‚ùå Fichier introuvable.");
             }
         } else {
             eprintln!("   ‚ö†Ô∏è XDG_CONFIG_HOME non trouv√© dans les variables d'environnement.");
         }
    }

    let mut cmd = Command::new(&config.emulator_path);
    
    if let Some(working_dir) = config.working_dir {
        cmd.current_dir(working_dir);
    }

    for (key, value) in config.env_vars {
        cmd.env(key, value);
    }

    // Determine if we need DuckStation specific HOME isolation
    let is_duckstation = config.emulator_path.to_string_lossy().to_lowercase().contains("duckstation");
    if is_duckstation {
        // Find if we have a .duckstation_home next to the executable
        if let Ok(exe_path) = env::current_exe() {
            if let Some(exe_dir) = exe_path.parent() {
                let fake_home = exe_dir.join(".duckstation_home");
                if fake_home.exists() {
                    cmd.env("HOME", fake_home);
                    cmd.env("QT_QPA_PLATFORM", "xcb");
                }
            }
        }
    }

    cmd.args(&config.args);
    
    // In launcher mode, if rom_path is not empty, we add it.
    // If it's a wrapper script, rom_path might have been cleared in the UI logic.
    if !config.rom_path.as_os_str().is_empty() {
        cmd.arg(&config.rom_path);
    }

    // Add arguments that come AFTER the ROM path (e.g., Cemu's -f for fullscreen)
    cmd.args(&config.args_after_rom);

    eprintln!("üöÄ DEBUG: Launching in LAUNCHER MODE: {:?}", cmd);
    
    // Check permissions for launcher mode too
    if let Ok(metadata) = fs::metadata(&config.emulator_path) {
        use std::os::unix::fs::PermissionsExt;
        eprintln!("   üìù Mode permissions: {:o}", metadata.permissions().mode());
    } else {
        eprintln!("   ‚ùå Executable not found or not accessible: {:?}", config.emulator_path);
    }

    let mut child = cmd.spawn().expect("Failed to launch emulator");
    let _ = child.wait();
}

/// V√©rifie si l'√©mulateur est Ryujinx (pour activer la d√©tection dynamique des manettes)
fn is_ryujinx_emulator(path: &std::path::Path) -> bool {
    // 1. V√©rifie le chemin complet (contient "ryujinx" quelque part)
    let full_path = path.to_string_lossy().to_lowercase();
    if full_path.contains("ryujinx") {
        return true;
    }
    
    // 2. V√©rifie si c'est un AppRun dans un dossier squashfs-root qui contient Ryujinx
    if path.file_name().map(|n| n == "AppRun").unwrap_or(false) {
        // Chercher usr/bin/Ryujinx dans le m√™me dossier
        if let Some(parent) = path.parent() {
            let ryujinx_bin = parent.join("usr/bin/Ryujinx");
            if ryujinx_bin.exists() {
                return true;
            }
            let ryujinx_bin_alt = parent.join("usr/bin/Ryujinx.sh");
            if ryujinx_bin_alt.exists() {
                return true;
            }
        }
    }
    
    // 3. Remonte les parents pour chercher "ryujinx" dans le chemin
    let mut current = path.parent();
    for _ in 0..5 {  // Max 5 niveaux
        if let Some(parent) = current {
            let parent_name = parent.file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("")
                .to_lowercase();
            if parent_name.contains("ryujinx") {
                return true;
            }
            current = parent.parent();
        } else {
            break;
        }
    }
    
    false
}

/// Detect if a gamepad is connected (Linux only for now)
fn detect_gamepad() -> bool {
    // Simple check: looking for /dev/input/js* devices
    if let Ok(entries) = std::fs::read_dir("/dev/input") {
        for entry in entries.flatten() {
            if let Some(name) = entry.file_name().to_str() {
                if name.starts_with("js") {
                    return true;
                }
            }
        }
    }
    false
}

/// Update Azahar config profile and GUID
fn update_azahar_profile(config_path: &PathBuf, profile_index: i32, new_guid: Option<&str>) -> io::Result<()> {
    // Read the file content
    let content = fs::read_to_string(config_path)?;
    let mut new_lines = Vec::new();
    let mut in_controls = false;

    // Detect if we need to replace GUID
    // We look for the hardcoded GUID from the generator or any existing GUID
    let guid_regex = regex::Regex::new(r"guid:[a-fA-F0-9]{32}").unwrap();

    for line in content.lines() {
        if line.trim() == "[Controls]" {
            in_controls = true;
            new_lines.push(line.to_string());
            continue;
        }

        if in_controls {
            if line.trim().starts_with("[") {
                in_controls = false; // Next section
            } else if line.trim().starts_with("profile=") {
                // Modify active profile
                new_lines.push(format!("profile={}", profile_index));
                continue;
            } else if line.trim().starts_with(r"profile\default") || line.trim().starts_with("profile/default") {
                // Force default to false so our profile choice is respected
                new_lines.push(r"profile\default=false".to_string());
                continue;
            }
            
            // GUID Replacement if available
            if let Some(guid) = new_guid {
                // Check if line contains a GUID
                if line.contains("guid:") {
                    let new_guid_str = format!("guid:{}", guid);
                    let new_line = guid_regex.replace(line, &new_guid_str).to_string();
                    new_lines.push(new_line);
                    continue;
                }
            }
        }
        
        new_lines.push(line.to_string());
    }

    // Write back
    fs::write(config_path, new_lines.join("\n"))?;
    Ok(())
}
