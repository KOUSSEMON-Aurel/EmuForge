use crate::forge::LaunchConfig;
use crate::plugin::{EmulatorPlugin, RequirementInfo, ValidationResult};
use crate::downloader::EmulatorDownloader;
use anyhow::{Result, Context};
use std::path::{Path, PathBuf};
use std::fs;
use std::io::Write;
use zip::ZipArchive;

pub struct XemuPlugin {
    pub custom_binary_path: Option<PathBuf>,
}

impl XemuPlugin {
    pub fn new(custom_binary_path: Option<PathBuf>) -> Self {
        Self { custom_binary_path }
    }

    /// Retourne le dossier de configuration xemu selon l'OS
    fn get_xemu_config_dir() -> Option<PathBuf> {
        if cfg!(target_os = "windows") {
            dirs::data_dir().map(|d| d.join("xemu").join("xemu"))
        } else {
            dirs::data_local_dir().map(|d| d.join("xemu").join("xemu"))
        }
    }

    /// G√©n√®re un fichier xemu.toml complet avec tous les param√®tres optimaux
    fn generate_xemu_toml(output_dir: &Path, use_relative_paths: bool) -> Result<PathBuf> {
        let toml_path = output_dir.join("xemu.toml");
        
        // Chemins des fichiers BIOS
        let (bootrom, flashrom, eeprom, hdd) = if use_relative_paths {
            // Mode portable: chemins relatifs
            (
                "mcpx_1.0.bin".to_string(),
                "bios.bin".to_string(),
                "eeprom.bin".to_string(),
                "xbox_hdd.qcow2".to_string(),
            )
        } else {
            // Mode normal: chemins absolus
            let config_dir = output_dir.to_string_lossy();
            (
                format!("{}/mcpx_1.0.bin", config_dir),
                format!("{}/bios.bin", config_dir),
                format!("{}/eeprom.bin", config_dir),
                format!("{}/xbox_hdd.qcow2", config_dir),
            )
        };

        // D√©tecter les manettes SDL2
        let input_bindings = Self::generate_input_bindings();

        let toml_content = format!(r#"# xemu configuration - Generated by EmuForge
# https://xemu.app

[general]
show_welcome = false

[sys]
mem_limit = '64'

[sys.files]
bootrom_path = '{bootrom}'
flashrom_path = '{flashrom}'
eeprom_path = '{eeprom}'
hdd_path = '{hdd}'

[display]
renderer = 'VULKAN'

[display.quality]
surface_scale = 3

[display.window]
fullscreen_on_startup = true
startup_size = '1920x1080'
last_width = 1920
last_height = 1080

[display.ui]
aspect_ratio = '16x9'
show_menubar = true
show_notifications = true
hide_cursor = true

{input_bindings}
"#);

        let mut file = fs::File::create(&toml_path)?;
        file.write_all(toml_content.as_bytes())?;
        
        println!("‚úÖ xemu.toml g√©n√©r√©: {:?}", toml_path);
        Ok(toml_path)
    }

    /// G√©n√®re la section [input.bindings] avec d√©tection SDL2 des manettes
    fn generate_input_bindings() -> String {
        // Initialiser SDL2 pour d√©tecter les manettes
        let mut bindings = String::new();
        bindings.push_str("[input]\nbackground_input_capture = true\n\n");
        
        // Essayer de d√©tecter les manettes avec SDL2
        match sdl2::init() {
            Ok(sdl) => {
                match sdl.game_controller() {
                    Ok(controller_subsystem) => {
                        let num_joysticks = controller_subsystem.num_joysticks().unwrap_or(0);
                        
                        if num_joysticks > 0 {
                            bindings.push_str("gamepad_mappings = [\n");
                            
                            for i in 0..std::cmp::min(num_joysticks, 4) {
                                if controller_subsystem.is_game_controller(i) {
                                    if let Ok(controller) = controller_subsystem.open(i) {
                                        // G√©n√©rer le GUID au format xemu (32 caract√®res hex)
                                        let guid = controller.instance_id();
                                        // xemu utilise un format GUID sp√©cifique
                                        let guid_str = format!("{:032x}", guid as u128);
                                        bindings.push_str(&format!("    {{ gamepad_id = '{}'}}\n", guid_str));
                                        println!("üéÆ Manette {} d√©tect√©e: {}", i + 1, controller.name());
                                    }
                                }
                            }
                            
                            bindings.push_str("]\n\n");
                        }
                        
                        // G√©n√©rer les bindings pour chaque port
                        bindings.push_str("[input.bindings]\n");
                        
                        // Toujours activer le clavier sur port 1
                        bindings.push_str("port1_driver = 'usb-xbox-gamepad'\n");
                        bindings.push_str("port1 = 'keyboard'\n");
                        
                        // Ajouter les manettes sur les ports 2-4
                        for port in 2..=4 {
                            let port_idx = port - 2; // port 2 = joystick 0, port 3 = joystick 1
                            if port_idx < num_joysticks && controller_subsystem.is_game_controller(port_idx) {
                                if let Ok(controller) = controller_subsystem.open(port_idx) {
                                    let guid_str = format!("{:032x}", controller.instance_id() as u128);
                                    bindings.push_str(&format!("port{}_driver = 'usb-xbox-gamepad'\n", port));
                                    bindings.push_str(&format!("port{} = '{}'\n", port, guid_str));
                                }
                            }
                        }
                    }
                    Err(_) => {
                        // Fallback: clavier uniquement
                        bindings.push_str("[input.bindings]\n");
                        bindings.push_str("port1_driver = 'usb-xbox-gamepad'\n");
                        bindings.push_str("port1 = 'keyboard'\n");
                    }
                }
            }
            Err(_) => {
                // Fallback: clavier uniquement
                bindings.push_str("[input.bindings]\n");
                bindings.push_str("port1_driver = 'usb-xbox-gamepad'\n");
                bindings.push_str("port1 = 'keyboard'\n");
            }
        }
        
        bindings
    }

    /// Scan r√©cursif pour trouver MCPX, BIOS et HDD
    fn deep_scan_for_files(dir: &Path, temp_extract_dir: &Path) -> (Option<PathBuf>, Option<PathBuf>, Option<PathBuf>) {
        let mut mcpx_file: Option<PathBuf> = None;
        let mut bios_file: Option<PathBuf> = None;
        let mut hdd_file: Option<PathBuf> = None;

        Self::scan_directory_recursive(dir, temp_extract_dir, &mut mcpx_file, &mut bios_file, &mut hdd_file);
        
        (mcpx_file, bios_file, hdd_file)
    }

    fn scan_directory_recursive(
        dir: &Path, 
        temp_extract_dir: &Path,
        mcpx_file: &mut Option<PathBuf>, 
        bios_file: &mut Option<PathBuf>, 
        hdd_file: &mut Option<PathBuf>
    ) {
        let entries = match fs::read_dir(dir) {
            Ok(e) => e,
            Err(_) => return,
        };

        for entry in entries.flatten() {
            let path = entry.path();
            
            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                let name_lower = name.to_lowercase();
                
                // MCPX Boot ROM (~512 bytes)
                if name_lower.contains("mcpx") && name_lower.ends_with(".bin") && mcpx_file.is_none() {
                    if let Ok(meta) = fs::metadata(&path) {
                        if meta.len() <= 1024 {
                            println!("üîç MCPX trouv√©: {:?}", path);
                            *mcpx_file = Some(path.clone());
                            continue;
                        }
                    }
                }
                
                // BIOS (~1MB)
                if (name_lower.contains("complex") || name_lower.contains("bios")) 
                    && name_lower.ends_with(".bin") && bios_file.is_none() {
                    if let Ok(meta) = fs::metadata(&path) {
                        if meta.len() >= 256 * 1024 && meta.len() <= 2 * 1024 * 1024 {
                            println!("üîç BIOS trouv√©: {:?}", path);
                            *bios_file = Some(path.clone());
                            continue;
                        }
                    }
                }
                
                // HDD Image
                if (name_lower.ends_with(".qcow2") || 
                    (name_lower.contains("hdd") && name_lower.ends_with(".img"))) 
                    && hdd_file.is_none() {
                    println!("üîç HDD trouv√©: {:?}", path);
                    *hdd_file = Some(path.clone());
                    continue;
                }
                
                // Archives ZIP
                if name_lower.ends_with(".zip") {
                    println!("üì¶ Extraction ZIP: {:?}", path);
                    if let Ok(extracted) = Self::extract_zip_to_temp(&path, temp_extract_dir) {
                        Self::scan_directory_recursive(&extracted, temp_extract_dir, mcpx_file, bios_file, hdd_file);
                    }
                    continue;
                }
                
                // Sous-dossiers
                if path.is_dir() {
                    Self::scan_directory_recursive(&path, temp_extract_dir, mcpx_file, bios_file, hdd_file);
                }
            }
        }
    }

    fn extract_zip_to_temp(zip_path: &Path, temp_dir: &Path) -> Result<PathBuf> {
        let file = fs::File::open(zip_path)?;
        let mut archive = ZipArchive::new(file)?;
        
        let zip_name = zip_path.file_stem().and_then(|s| s.to_str()).unwrap_or("archive");
        let extract_dir = temp_dir.join(zip_name);
        fs::create_dir_all(&extract_dir)?;
        
        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            let outpath = match file.enclosed_name() {
                Some(path) => extract_dir.join(path),
                None => continue,
            };
            
            if file.name().ends_with('/') {
                fs::create_dir_all(&outpath)?;
            } else {
                if let Some(parent) = outpath.parent() {
                    fs::create_dir_all(parent)?;
                }
                let mut outfile = fs::File::create(&outpath)?;
                std::io::copy(&mut file, &mut outfile)?;
            }
        }
        
        Ok(extract_dir)
    }
}

impl XemuPlugin {

    /// V√©rifie si l'ISO est un XISO valide, sinon le convertit
    fn ensure_xiso(&self, rom_path: &Path, progress: Option<&dyn Fn(String)>) -> Result<PathBuf> {
        if self.is_xiso(rom_path)? {
            if let Some(cb) = progress { cb("‚úÖ Valid XISO detected".to_string()); }
            return Ok(rom_path.to_path_buf());
        }

        if let Some(cb) = progress { cb("‚ö†Ô∏è Redump ISO detected. Starting conversion...".to_string()); }
        
        // D√©terminer le chemin du cache
        let cache_dir = dirs::cache_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("emuforge")
            .join("xiso");
        fs::create_dir_all(&cache_dir)?;

        // Sanitize filename to avoid issues with extract-xiso or xemu
        let original_name = rom_path.file_stem().and_then(|n| n.to_str()).unwrap_or("game");
        let safe_name: String = original_name.chars()
            .map(|c| if c.is_alphanumeric() || c == '-' || c == '_' { c } else { '_' })
            .collect();
        let rom_name = format!("{}.iso", safe_name);
        let cached_xiso = cache_dir.join(rom_name);

        if cached_xiso.exists() {
            if let Some(cb) = progress { cb("‚ôªÔ∏è Using cached XISO".to_string()); }
            return Ok(cached_xiso);
        }

        // Trouver extract-xiso
        let extract_tool = self.find_extract_xiso().or_else(|| {
            if let Some(cb) = progress { cb("üì• Downloading extract-xiso tool...".to_string()); }
            match self.download_extract_xiso() {
                Ok(path) => Some(path),
                Err(e) => {
                    println!("Error downloading extract-xiso: {}", e);
                    if let Some(cb) = progress { cb(format!("‚ùå Download failed: {}", e)); }
                    None
                }
            }
        }).context("extract-xiso tool not found and download failed. Please check internet connection.")?;

        if let Some(cb) = progress { cb("üîÑ Converting ISO to XISO...".to_string()); }
        self.run_conversion(&extract_tool, rom_path, &cached_xiso)?;
        
        if let Some(cb) = progress { cb("‚úÖ Conversion complete!".to_string()); }
        Ok(cached_xiso)
    }

    fn is_xiso(&self, path: &Path) -> Result<bool> {
        let mut file = fs::File::open(path)?;
        let mut buffer = [0u8; 20];
        use std::io::Read;
        file.read_exact(&mut buffer)?;
        
        // XISO commence par "MICROSOFT*XBOX*MEDIA" √† 0x0
        Ok(buffer.starts_with(b"MICROSOFT*XBOX*MEDIA"))
    }

    fn find_extract_xiso(&self) -> Option<PathBuf> {
        // 1. PATH
        if let Ok(path) = which::which("extract-xiso") {
            return Some(path);
        }

        // 2. EmuForge emulators dir
        if let Some(mut dir) = dirs::home_dir() {
            dir.push(".emuforge");
            dir.push("emulators");
            dir.push("extract-xiso");
            
            let binary_name = if cfg!(target_os = "windows") { "extract-xiso.exe" } else { "extract-xiso" };
            let candidate = dir.join(binary_name);
            if candidate.exists() {
                return Some(candidate);
            }
        }

        None
    }

    fn run_conversion(&self, tool: &Path, input: &Path, output: &Path) -> Result<()> {
        // extract-xiso -r modifies in place. We MUST copy first.
        println!("   Copying to cache...");
        fs::copy(input, output)?;
        
        // Get the directory containing the output file
        let output_dir = output.parent().context("Invalid output path")?;
        let output_filename = output.file_name().context("Invalid output filename")?;
        
        println!("   Running extract-xiso -r...");
        let status = std::process::Command::new(tool)
            .arg("-r")
            .arg(output_filename)  // Just the filename, not full path
            .current_dir(output_dir)  // Run in the cache directory
            .status()?;

        if status.success() {
            // Cleanup: extract-xiso creates .old backup, remove it
            let old_file = output.with_extension("iso.old");
            if old_file.exists() {
                let _ = fs::remove_file(&old_file);
                println!("   Cleaned up backup file");
            }
            println!("‚úÖ Conversion successful!");
            Ok(())
        } else {
            // Nettoyage si √©chec
            let _ = fs::remove_file(output);
            Err(anyhow::anyhow!("extract-xiso failed with status: {}", status))
        }
    }

    fn download_extract_xiso(&self) -> Result<PathBuf> {
        // Spawn a separate thread to run the temporary runtime and avoid "runtime within runtime" panic
        // because forge_executable is already running on a tokio runtime.
        std::thread::spawn(|| {
            let rt = tokio::runtime::Builder::new_current_thread()
                .enable_all()
                .build()?;
                
            rt.block_on(async {
                let base_dir = dirs::home_dir().unwrap_or(PathBuf::from(".")).join(".emuforge/emulators");
                let downloader = EmulatorDownloader::new(base_dir);
                downloader.download("extract-xiso").await
            })
        }).join().map_err(|_| anyhow::anyhow!("Download thread panicked"))?
    }
}

impl EmulatorPlugin for XemuPlugin {
    fn id(&self) -> &str { "xemu" }
    fn name(&self) -> &str { "xemu (Xbox)" }
    fn supported_extensions(&self) -> &[&str] { &["iso", "xiso"] }

    fn find_binary(&self) -> Result<PathBuf> {
        if let Some(path) = &self.custom_binary_path {
            if path.exists() { return Ok(path.clone()); }
        }
        if let Ok(path) = which::which("xemu") { return Ok(path); }
        
        Err(anyhow::anyhow!("xemu executable not found."))
    }

    fn prepare_launch_config(&self, rom_path: &Path, output_dir: &Path) -> Result<LaunchConfig> {
        self.prepare_launch_config_with_progress(rom_path, output_dir, None)
    }

    fn prepare_launch_config_with_progress(
        &self, 
        rom_path: &Path, 
        _output_dir: &Path, 
        progress: Option<&dyn Fn(String)>
    ) -> Result<LaunchConfig> {
        let binary = self.find_binary().context("Failed to locate xemu binary")?;
        
        // Ensure XISO format (auto-convert Redump ISOs)
        let final_rom_path = self.ensure_xiso(rom_path, progress).unwrap_or_else(|e| {
            eprintln!("‚ö†Ô∏è Warning: XISO check/conversion failed: {}. Using original ROM.", e);
            if let Some(cb) = progress { cb(format!("‚ö†Ô∏è Conversion failed: {}", e)); }
            rom_path.to_path_buf()
        });

        // xemu Args: -dvd_path <iso> -full-screen -machine xbox,short-animation=on
        let args = vec![
            "-dvd_path".to_string(),
        ];

        // Arguments apr√®s la ROM: fullscreen + skip animation
        let args_after_rom = vec![
            "-full-screen".to_string(),
            "-machine".to_string(),
            "xbox,short-animation=on".to_string(),
        ];

        Ok(LaunchConfig {
            emulator_path: binary,
            rom_path: final_rom_path,
            bios_path: None, 
            args,
            working_dir: None, 
            args_after_rom,
            env_vars: vec![],
        })
    }



    fn can_handle(&self, binary_path: &Path) -> bool {
        let name = binary_path.file_name().and_then(|n| n.to_str()).unwrap_or("").to_lowercase();
        name.contains("xemu")
    }

    fn fullscreen_args(&self) -> Vec<String> {
        // Pour xemu, fullscreen doit √™tre AVANT -dvd_path
        // On le g√®re dans prepare_launch_config ou via le TOML
        // Retourner vide pour √©viter le mauvais ordre
        vec![]
    }

    fn clone_with_path(&self, binary_path: PathBuf) -> Box<dyn EmulatorPlugin> {
        Box::new(XemuPlugin::new(Some(binary_path)))
    }

    /// Configure l'environnement xemu: copie BIOS + g√©n√®re xemu.toml
    fn setup_environment(&self, output_dir: &Path, bios_path: Option<&Path>) -> Result<()> {
        // Structure: xemu_data/xemu/xemu/ pour $XDG_DATA_HOME
        let xemu_data = output_dir.join("xemu_data").join("xemu").join("xemu");
        fs::create_dir_all(&xemu_data)?;

        // Scanner et copier les fichiers BIOS
        if let Some(bios_dir) = bios_path {
            if bios_dir.exists() && bios_dir.is_dir() {
                let temp_dir = std::env::temp_dir().join(format!("emuforge_xemu_setup_{}", std::process::id()));
                fs::create_dir_all(&temp_dir)?;

                let (found_mcpx, found_bios, found_hdd) = Self::deep_scan_for_files(bios_dir, &temp_dir);

                if let Some(mcpx) = found_mcpx {
                    fs::copy(&mcpx, xemu_data.join("mcpx_1.0.bin"))?;
                    println!("üìã MCPX copi√© vers xemu_data");
                }

                if let Some(bios) = found_bios {
                    fs::copy(&bios, xemu_data.join("bios.bin"))?;
                    println!("üìã BIOS copi√© vers xemu_data");
                }

                if let Some(hdd) = found_hdd {
                    fs::copy(&hdd, xemu_data.join("xbox_hdd.qcow2"))?;
                    println!("üìã HDD copi√© vers xemu_data");
                }

                let _ = fs::remove_dir_all(&temp_dir);
            }
        }

        // G√©n√©rer xemu.toml avec chemins relatifs pour portabilit√©
        Self::generate_xemu_toml(&xemu_data, true)?;

        Ok(())
    }

    /// Variables d'environnement pour mode portable
    fn portable_env_vars(&self, config_dir: &Path) -> Vec<(String, String)> {
        vec![
            ("XDG_DATA_HOME".to_string(), config_dir.to_string_lossy().to_string()),
        ]
    }

    /// Arguments de lancement pour mode portable
    fn portable_launch_args(&self, fullscreen: bool) -> (Vec<String>, Vec<String>) {
        // -full-screen DOIT √™tre AVANT -dvd_path
        let mut before = Vec::new();
        if fullscreen {
            before.push("-full-screen".to_string());
        }
        before.push("-dvd_path".to_string());
        
        // Skip l'animation Xbox
        let after = vec![
            "-machine".to_string(),
            "xbox,short-animation=on".to_string(),
        ];
        
        (before, after)
    }

    fn get_requirements(&self) -> RequirementInfo {
        RequirementInfo {
            needs_bios: true,
            needs_firmware: true,
            keys_file: None,
            description: "xemu requires MCPX Boot ROM, BIOS (Complex_4627), and HDD image.".to_string(),
        }
    }

    fn validate_requirements(&self, source_path: Option<&Path>) -> Result<ValidationResult> {
        let xemu_config = Self::get_xemu_config_dir()
            .ok_or_else(|| anyhow::anyhow!("Could not determine xemu config directory"))?;

        let mcpx_path = xemu_config.join("mcpx_1.0.bin");
        let bios_path = xemu_config.join("bios.bin");
        let hdd_path = xemu_config.join("xbox_hdd.qcow2");
        let toml_path = xemu_config.join("xemu.toml");

        let mcpx_exists = mcpx_path.exists();
        let bios_exists = bios_path.exists();
        let hdd_exists = hdd_path.exists();

        if mcpx_exists && bios_exists && hdd_exists && source_path.is_none() {
            // Reg√©n√©rer le TOML si manquant
            if !toml_path.exists() {
                let _ = Self::generate_xemu_toml(&xemu_config, false);
            }
            return Ok(ValidationResult { 
                valid: true, 
                message: "‚úÖ MCPX, BIOS et HDD d√©j√† install√©s.".to_string(), 
                fixed: false 
            });
        }

        let src = match source_path {
            Some(s) if s.exists() && s.is_dir() => s,
            Some(_) => return Ok(ValidationResult { 
                valid: false, 
                message: "Dossier invalide.".to_string(), 
                fixed: false 
            }),
            None => {
                let mut missing = Vec::new();
                if !mcpx_exists { missing.push("MCPX"); }
                if !bios_exists { missing.push("BIOS"); }
                if !hdd_exists { missing.push("HDD"); }
                
                if missing.is_empty() {
                    return Ok(ValidationResult { 
                        valid: true, 
                        message: "‚úÖ Tous les fichiers sont pr√©sents.".to_string(), 
                        fixed: false 
                    });
                } else {
                    return Ok(ValidationResult { 
                        valid: false, 
                        message: format!("‚ùå Fichiers manquants: {}. S√©lectionnez un dossier.", missing.join(", ")), 
                        fixed: false 
                    });
                }
            }
        };

        let temp_dir = std::env::temp_dir().join(format!("emuforge_xemu_{}", std::process::id()));
        fs::create_dir_all(&temp_dir)?;

        let (found_mcpx, found_bios, found_hdd) = Self::deep_scan_for_files(src, &temp_dir);

        fs::create_dir_all(&xemu_config)?;

        let mcpx_installed = if let Some(ref mcpx) = found_mcpx {
            fs::copy(mcpx, &mcpx_path)?;
            println!("‚úÖ MCPX install√©: {:?}", mcpx_path);
            true
        } else {
            mcpx_exists
        };

        let bios_installed = if let Some(ref bios) = found_bios {
            fs::copy(bios, &bios_path)?;
            println!("‚úÖ BIOS install√©: {:?}", bios_path);
            true
        } else {
            bios_exists
        };

        let hdd_installed = if let Some(ref hdd) = found_hdd {
            fs::copy(hdd, &hdd_path)?;
            println!("‚úÖ HDD install√©: {:?}", hdd_path);
            true
        } else {
            hdd_exists
        };

        let _ = fs::remove_dir_all(&temp_dir);

        // G√©n√©rer xemu.toml avec les chemins absolus
        if mcpx_installed && bios_installed && hdd_installed {
            let _ = Self::generate_xemu_toml(&xemu_config, false);
        }

        let all_installed = mcpx_installed && bios_installed && hdd_installed;
        let mut status = Vec::new();
        if mcpx_installed { status.push("MCPX ‚úÖ"); } else { status.push("MCPX ‚ùå"); }
        if bios_installed { status.push("BIOS ‚úÖ"); } else { status.push("BIOS ‚ùå"); }
        if hdd_installed { status.push("HDD ‚úÖ"); } else { status.push("HDD ‚ùå"); }

        let message = if all_installed {
            format!("‚úÖ Installation compl√®te! {} + xemu.toml g√©n√©r√©", status.join(" | "))
        } else {
            format!("‚ö†Ô∏è Installation partielle: {}", status.join(" | "))
        };

        Ok(ValidationResult { 
            valid: all_installed, 
            message, 
            fixed: found_mcpx.is_some() || found_bios.is_some() || found_hdd.is_some() 
        })
    }
}
